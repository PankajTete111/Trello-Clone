"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CookieAdapter = exports.axiosToken = void 0;
class AxiosToken {
    axios;
    options;
    token = null;
    tokenKey = "axios-token";
    constructor(axios, options = {}) {
        this.axios = axios;
        this.options = options;
        if (typeof window !== "undefined") {
            this.options.storage ||= sessionStorage;
            this.options.storageKey ||= this.tokenKey;
        }
        this.handle();
    }
    getToken(key) {
        if (typeof window === "undefined")
            return this.token;
        const tokenString = this.options.storage?.getItem(this.options.storageKey);
        if (!tokenString)
            return null;
        const token = JSON.parse(tokenString);
        if (key) {
            if (token && key in token)
                return token[key];
            return null;
        }
        return token;
    }
    setToken(token) {
        token[this.options.accessTokenExpiresInKey] < Date.now() - 3600 &&
            // @ts-ignore
            (token[this.options.accessTokenExpiresInKey] = Date.now() + token[this.options.accessTokenExpiresInKey] * 1000);
        if (typeof window !== "undefined") {
            this.options.storage?.setItem(this.options.storageKey, JSON.stringify(token));
        }
        this.token = token;
    }
    clearToken() {
        if (typeof window !== "undefined") {
            this.options.storage?.removeItem(this.options.storageKey);
        }
        this.token = null;
    }
    async refreshToken() {
        await this.updateToken();
    }
    handle() {
        this.axios.interceptors.request.use(async (config) => {
            const token = this.getToken();
            this.options.accessTokenKey ||= "accessToken";
            this.options.accessTokenExpiresInKey ||= "accessTokenExpiresIn";
            if (!token || config.url === this.options.refreshTokenUrl) {
                return config;
            }
            if (token[this.options.accessTokenKey] && Date.now() < token[this.options.accessTokenExpiresInKey]) {
                config.headers.Authorization = `Bearer ${token[this.options.accessTokenKey]}`;
            }
            else {
                try {
                    await this.updateToken();
                    Object.assign(token, this.getToken());
                    config.headers.Authorization = `Bearer ${token[this.options.accessTokenKey]}`;
                }
                catch (error) {
                    this.options.onError(error);
                }
            }
            return config;
        });
        this.axios.interceptors.response.use((response) => {
            return response;
        }, async (error) => {
            if (error.response && error.response.status === 401) {
                await this.refreshToken();
            }
            return Promise.reject(error);
        });
    }
    async updateToken(error) {
        const token = this.getToken();
        try {
            const { data: newToken } = await this.axios.post(this.options.refreshTokenUrl, { [this.options.refreshTokenKey]: token[this.options.refreshTokenKey] }, { headers: { Authorization: `Bearer ${token[this.options.accessTokenKey]}` } });
            this.setToken(newToken);
            Object.assign(token, newToken);
            if (error) {
                const config = error.config;
                config.headers.Authorization = `Bearer ${token[this.options.accessTokenKey]}`;
                return this.axios.request(config);
            }
            else {
                return newToken;
            }
        }
        catch (error) {
            this.options.onExpired(error);
        }
    }
}
const axiosToken = (axios, options) => new AxiosToken(axios, options);
exports.axiosToken = axiosToken;
var cookie_adapter_1 = require("./utils/cookie-adapter");
Object.defineProperty(exports, "CookieAdapter", { enumerable: true, get: function () { return cookie_adapter_1.CookieAdapter; } });
